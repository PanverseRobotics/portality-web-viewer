<!DOCTYPE html>
<html>

<head>
    <title>Test page.</title>
    <script src="./lib/utils/linalg.js" type="module"></script>
    <script src="../../lib/pipeline.js" type="module"></script>
    <script src="./lib/rendering/shaders.js"></script>
</head>

<body>
    <h1>Rendering test page.</h1>
    <p>Page containing basic rendering test.</p>
    <div> fps: <span id="fps"></span></div>
    <div>average fps: <span id="avg"></span></div>
    <canvas id="gl-canvas" width="1024" height="1024"></canvas>
</body>

<script type="module">
    const canvasWidth = 1024;
    const canvasHeight = 1024;

    import { mat3transpose, mat3multiply, mat4multiply, mat4perspective, mat4lookAt } from '../lib/utils/linalg.js';
    import { rotorToRotationMatrix, rotorsToCov3D } from '../lib/utils/rotors.js';
    import { createPipeline, applyPipeline } from '../lib/pipeline.js';
    import { permuteArray } from '../lib/pointarray.js';
    import loadSplatFile from '../lib/splatfile.js';

    const fpsElem = document.querySelector("#fps");
    const avgElem = document.querySelector("#avg");

    let fpsData = {
        then: 0,
        frameTimes: [],
        frameCursor: 0,
        numFrames: 0,
        maxFrames: 20,
        totalFPS: 0
    };

    function initCanvas() {
        var canvas = document.getElementById("gl-canvas");
        //canvas.width = window.innerWidth;
        //canvas.height = window.innerHeight;

        return canvas;
    }

    function initWebgl(canvas) {
        var gl = canvas.getContext("webgl2");

        if (!gl) {
            console.error("WebGL 2 not available");
            document.body.innerHTML = "This example requires WebGL 2 which is unavailable on this system."
        }

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        // gl.enable(gl.BLEND);
        // gl.depthMask(false);
        gl.clear(gl.COLOR_BUFFER_BIT);

        if (!gl.getExtension("EXT_color_buffer_float")) {
            console.error("FLOAT color buffer not available");
            document.body.innerHTML = "This example requires EXT_color_buffer_float which is unavailable on this system."
        }

        return gl;
    }

    function updateFPSDisplay(fps, averageFPS) {
        fpsElem.textContent = fps.toFixed(1);  // update fps display
        avgElem.textContent = averageFPS.toFixed(1);  // update avg display
    }

    function calcFPS(now) {
        const deltaTime = now - fpsData.then;
        fpsData.then = now;
        const fps = 1000 / deltaTime;

        // add the current fps and remove the oldest fps
        fpsData.totalFPS += fps - (fpsData.frameTimes[fpsData.frameCursor] || 0);

        // record the newest fps
        fpsData.frameTimes[fpsData.frameCursor++] = fps;

        // needed so the first N frames, before we have maxFrames, is correct.
        fpsData.numFrames = Math.max(fpsData.numFrames, fpsData.frameCursor);

        // wrap the cursor
        fpsData.frameCursor %= fpsData.maxFrames;

        updateFPSDisplay(fps, fpsData.totalFPS / fpsData.numFrames);
    }

    function renderMain(data) {
        let canvas = initCanvas();
        let gl = initWebgl(canvas);

        let shaderProgram = createRenderProgram(gl);

        // Create objects
        var GROUP_SIZE = 256;
        var N_GROUPS = 2048;

        var NUM_PARTICLES = GROUP_SIZE * N_GROUPS;
        var SORT_INTERVAL = 4;

        let positionData = data.positions;
        let colorData = data.colors;

        let covData = rotorsToCov3D(data.scales, data.rotors);
        let covDiagData = covData.diag;
        let covUpperData = covData.upper;

        // Create buffers for the particle positions and colors.
        var positionBuffer = gl.createBuffer();
        var colorBuffer = gl.createBuffer();
        var covDiagBuffer = gl.createBuffer();
        var covUpperBuffer = gl.createBuffer();

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        var projMatrix = new Float32Array(16);
        var viewMatrix = new Float32Array(16);
        var eyePosition = [0, 0, 2];
        var viewProjMatrix = new Float32Array(16);

        var viewportScale = new Float32Array([canvas.width, canvas.height]);

        gl.useProgram(shaderProgram);

        var image = new Image();

        var buffer = gl.createBuffer();
        // make this buffer the current 'ELEMENT_ARRAY_BUFFER'
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
        gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint32Array(32),
            gl.STATIC_DRAW
        );

        let pipeline = createPipeline(gl, positionData, N_GROUPS, GROUP_SIZE);
        positionData = permuteArray(positionData, pipeline.perm, 3);
        colorData = permuteArray(colorData, pipeline.perm, 4);
        covDiagData = permuteArray(covDiagData, pipeline.perm, 3);
        covUpperData = permuteArray(covUpperData, pipeline.perm, 3);

        let elementArrayData = new Uint32Array(NUM_PARTICLES);

        // Set buffers -----------------------------------------------------
        // Bind vertex position and color data.
        // We ideally want to avoid having to do this each step.
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positionData, gl.DYNAMIC_COPY);
        var positionLoc = gl.getAttribLocation(shaderProgram, "position");
        gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionLoc);

        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colorData, gl.DYNAMIC_COPY);
        var colorLoc = gl.getAttribLocation(shaderProgram, "color");
        gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(colorLoc);

        gl.bindBuffer(gl.ARRAY_BUFFER, covDiagBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, covDiagData, gl.DYNAMIC_COPY);
        var covDiagLoc = gl.getAttribLocation(shaderProgram, "covDiag");
        gl.vertexAttribPointer(covDiagLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(covDiagLoc);

        gl.bindBuffer(gl.ARRAY_BUFFER, covUpperBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, covUpperData, gl.DYNAMIC_COPY);
        var covUpperLoc = gl.getAttribLocation(shaderProgram, "covUpper");
        gl.vertexAttribPointer(covUpperLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(covUpperLoc);

        image.onload = function () {
            var rotationMatrix = new Float32Array(16);

            var angl = 0.0;
            var i = 0;

            function draw(now) {
                // Set scene transforms.
                angl += 0.01;

                mat4perspective(projMatrix, Math.PI / 3, canvas.width / canvas.height, 0.1, 20.0);
                eyePosition = [5.0 * Math.sin(angl), 0.0, 5.0 * Math.cos(angl)];
                mat4lookAt(viewMatrix, eyePosition, [0, 0, 0], [0, -1, 0]);
                mat4multiply(viewProjMatrix, projMatrix, viewMatrix);

                // apply sorting pipeline.
                let idxPerm;
                if (i % SORT_INTERVAL == 0) {
                    idxPerm = applyPipeline(gl, pipeline, eyePosition, viewProjMatrix);
                }

                // Set scene transform uniforms.
                gl.useProgram(shaderProgram);
                gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, 'uView'), false, viewMatrix);
                gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, 'uViewProj'), false, viewProjMatrix);
                gl.uniform3fv(gl.getUniformLocation(shaderProgram, 'uEyePosition'), eyePosition);
                gl.uniform2fv(gl.getUniformLocation(shaderProgram, 'uViewportScale'), viewportScale);

                // Set element array buffer to data from sorting pipeline.
                if (i % SORT_INTERVAL == 0) {
                    elementArrayData.set(idxPerm.toArray());
                    gl.bufferData(
                        gl.ELEMENT_ARRAY_BUFFER,
                        elementArrayData,
                        gl.DYNAMIC_DRAW
                    );
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                }
                i = i + 1;

                // Set viewport params.
                gl.viewport(0, 0, canvasWidth, canvasHeight);
                gl.enable(gl.SCISSOR_TEST);
                gl.scissor(0, 0, canvasWidth, canvasHeight);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                // Prepare viewport for rendering and blending.
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.clear(gl.DEPTH_BUFFER_BIT);
                gl.disable(gl.DEPTH_TEST);
                gl.enable(gl.BLEND);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);                //gl.drawArrays(gl.POINTS, 0, NUM_PARTICLES);

                // Draw all the vertices as points, in the order given in the element array buffer.
                gl.drawElements(gl.POINTS, NUM_PARTICLES, gl.UNSIGNED_INT, 0);

                // Reset values of variables so that other shaders can run.
                gl.enable(gl.DEPTH_TEST);
                gl.disable(gl.BLEND);

                calcFPS(now);

                requestAnimationFrame(draw);
            }

            requestAnimationFrame(draw);

        }

        image.src = "img/house.png";
    }

    function main() {
        loadSplatFile('./train.splat', renderMain);
    }


    main();

</script>

</html>