<!DOCTYPE html>
<html>

<head>
    <title>Test page.</title>
    <script src="./lib/utils/linalg.js"></script>
    <script src="../../lib/pipeline.js" type="module"></script>
    <script src="./lib/rendering/shaders.js"></script>
</head>

<body>
    <h1>Rendering test page.</h1>
    <p>Page containing basic rendering test.</p>
    <canvas id="gl-canvas" width="768" height="768"></canvas>
</body>

<script type="module">
    const canvasWidth = 768;
    const canvasHeight = 768;

    import { createPipeline, applyPipeline } from '../lib/pipeline.js';
    import { permuteArray } from '../lib/pointarray.js';

    function initCanvas(){
        var canvas = document.getElementById("gl-canvas");
        //canvas.width = window.innerWidth;
        //canvas.height = window.innerHeight;

        return canvas;
    }

    function initWebgl(canvas){
        var gl = canvas.getContext("webgl2");

        if (!gl) {
            console.error("WebGL 2 not available");
            document.body.innerHTML = "This example requires WebGL 2 which is unavailable on this system."
        }

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        // gl.enable(gl.BLEND);
        // gl.depthMask(false);
        gl.clear(gl.COLOR_BUFFER_BIT);

        if (!gl.getExtension("EXT_color_buffer_float")) {
            console.error("FLOAT color buffer not available");
            document.body.innerHTML = "This example requires EXT_color_buffer_float which is unavailable on this system."
        }

        return gl;
    }

    // Standard Normal variate using Box-Muller transform.
    function gaussianRandom(mean=0, stdev=1) {
        const u = 1 - Math.random(); // Converting [0,1) to (0,1]
        const v = Math.random();
        const z = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
        // Transform to the desired mean and standard deviation:
        return z * stdev + mean;
    }

    function randomCovariance(scale){
        let a  = new Float32Array(9);
        let at = new Float32Array(9);
        let s  = new Float32Array(9);

        for(var i=0; i<9; ++i){
            a[i] = gaussianRandom(0, scale);
        }

        mat3transpose(at, a);
        mat3multiply(s, at, a);

        return s;
    }

    function main() {
        let canvas = initCanvas();
        let gl = initWebgl(canvas);

        let shaderProgram = createRenderProgram(gl);

        // Create objects
        var GROUP_SIZE = 64;
        var N_GROUPS = 512;
        var NUM_PARTICLES = GROUP_SIZE*N_GROUPS;
        var PARTICLE_SIZE = 10.0;
        var particles = new Array(NUM_PARTICLES);

        var positionData = new Float32Array(NUM_PARTICLES * 3);
        var colorData = new Float32Array(NUM_PARTICLES * 4);
        var covDiagData  = new Float32Array(NUM_PARTICLES * 3);
        var covUpperData = new Float32Array(NUM_PARTICLES * 3);

        for (var i = 0; i < NUM_PARTICLES; ++i) {
            var x = (Math.random() - 0.5);
            var y = (Math.random() - 0.5);
            var z = (Math.random() - 0.5);
            particles[i] = {
                scale: [1.0, 1.0, 1.0],
                rotate: [0, 0, 0], // Will be used for global rotation
                translate: [x, y, z],
            };

            positionData.set([x, y, z], i * 3);

            var col = [Math.random(), 0.1, 0.3, 1.0];
            if (z < 0){
                col = [0.1, 0.1, 0.9, 1.0];
            }

            colorData.set(col, i * 4);

            let s = randomCovariance(5e-3);
            covDiagData.set([s[3*0+0], s[3*1+1], s[3*2+2]], i * 3);
            covUpperData.set([s[3*1+0], s[3*2+0], s[3*2+1]], i * 3);
        }


        // Create buffers for the particle positions and colors.
        var positionBuffer = gl.createBuffer();
        var colorBuffer = gl.createBuffer();
        var covDiagBuffer = gl.createBuffer();
        var covUpperBuffer = gl.createBuffer();

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);


        var projMatrix = new Float32Array(16); 
        var viewMatrix = new Float32Array(16);
        var eyePosition = [0, 0, 2];
        var viewProjMatrix = new Float32Array(16); 

        var viewportScale = new Float32Array([canvas.width, canvas.height]);

        gl.useProgram(shaderProgram);

        var image = new Image();

        var buffer = gl.createBuffer();
        // make this buffer the current 'ELEMENT_ARRAY_BUFFER'
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
        gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint32Array(32),
            gl.STATIC_DRAW
        );

        let pipeline = createPipeline(gl, positionData, N_GROUPS, GROUP_SIZE);
        positionData = permuteArray(positionData, pipeline.perm, 3);
        colorData = permuteArray(colorData, pipeline.perm, 4);

        let elementArrayData = new Uint32Array(NUM_PARTICLES);

        // Set buffers -----------------------------------------------------
        // Bind vertex position and color data.
        // We ideally want to avoid having to do this each step.
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positionData, gl.DYNAMIC_COPY);
        var positionLoc = gl.getAttribLocation(shaderProgram, "position");
        gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionLoc);

        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colorData, gl.DYNAMIC_COPY);
        var colorLoc = gl.getAttribLocation(shaderProgram, "color");
        gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(colorLoc);

        gl.bindBuffer(gl.ARRAY_BUFFER, covDiagBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, covDiagData, gl.DYNAMIC_COPY);
        var covDiagLoc = gl.getAttribLocation(shaderProgram, "covDiag");
        gl.vertexAttribPointer(covDiagLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(covDiagLoc);

        gl.bindBuffer(gl.ARRAY_BUFFER, covUpperBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, covUpperData, gl.DYNAMIC_COPY);
        var covUpperLoc = gl.getAttribLocation(shaderProgram, "covUpper");
        gl.vertexAttribPointer(covUpperLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(covUpperLoc);

        image.onload = function() {
            var rotationMatrix = new Float32Array(16);

            var angl = 0.0; 

            function draw() {
                i=i+1;

                // Set scene transforms.
                angl += 0.02;
            
                mat4perspective(projMatrix, Math.PI / 2, canvas.width / canvas.height, 0.1, 10.0);
                eyePosition = [1.4*Math.sin(angl), 0.3, 1.4*Math.cos(angl)];
                mat4lookAt(viewMatrix, eyePosition, [0, 0, 0], [0, 1, 0]);
                mat4multiply(viewProjMatrix, projMatrix, viewMatrix);

                // apply sorting pipeline.
                let idxPerm = applyPipeline(gl, pipeline, eyePosition, viewProjMatrix); 

                // Set scene transform uniforms.
                gl.useProgram(shaderProgram);
                gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, 'uView'), false, viewMatrix);
                gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, 'uViewProj'), false, viewProjMatrix);
                gl.uniform3fv(gl.getUniformLocation(shaderProgram, 'uEyePosition'), eyePosition);
                gl.uniform2fv(gl.getUniformLocation(shaderProgram, 'uViewportScale'), viewportScale);

                // Set element array buffer to data from sorting pipeline.
                elementArrayData.set(idxPerm.toArray());
                gl.bufferData(
                    gl.ELEMENT_ARRAY_BUFFER,
                    elementArrayData,
                    gl.DYNAMIC_DRAW
                );
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);

                // Set viewport params.
                gl.viewport(0, 0, canvasWidth, canvasHeight);
                gl.enable(gl.SCISSOR_TEST);
                gl.scissor(0, 0, canvasWidth, canvasHeight);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null); 

                // Prepare viewport for rendering and blending.
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.clear(gl.DEPTH_BUFFER_BIT);
                gl.disable(gl.DEPTH_TEST);
                gl.enable(gl.BLEND);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);                //gl.drawArrays(gl.POINTS, 0, NUM_PARTICLES);
                
                // Draw all the vertices as points, in the order given in the element array buffer.
                gl.drawElements(gl.POINTS, NUM_PARTICLES, gl.UNSIGNED_INT, 0);     

                // Reset values of variables so that other shaders can run.
                gl.enable(gl.DEPTH_TEST);
                gl.disable(gl.BLEND);

                requestAnimationFrame(draw);
            }

            requestAnimationFrame(draw);
            
        }

        image.src = "img/house.png";
    }

    main();

</script>

</html>